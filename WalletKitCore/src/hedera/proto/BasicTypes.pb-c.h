/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: BasicTypes.proto */

#ifndef PROTOBUF_C_BasicTypes_2eproto__INCLUDED
#define PROTOBUF_C_BasicTypes_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004000 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "Timestamp.pb-c.h"

typedef struct Proto__ShardID Proto__ShardID;
typedef struct Proto__RealmID Proto__RealmID;
typedef struct Proto__AccountID Proto__AccountID;
typedef struct Proto__FileID Proto__FileID;
typedef struct Proto__ContractID Proto__ContractID;
typedef struct Proto__TransactionID Proto__TransactionID;
typedef struct Proto__AccountAmount Proto__AccountAmount;
typedef struct Proto__TransferList Proto__TransferList;
typedef struct Proto__NftTransfer Proto__NftTransfer;
typedef struct Proto__TokenTransferList Proto__TokenTransferList;
typedef struct Proto__Fraction Proto__Fraction;
typedef struct Proto__TopicID Proto__TopicID;
typedef struct Proto__TokenID Proto__TokenID;
typedef struct Proto__ScheduleID Proto__ScheduleID;
typedef struct Proto__Key Proto__Key;
typedef struct Proto__ThresholdKey Proto__ThresholdKey;
typedef struct Proto__KeyList Proto__KeyList;
typedef struct Proto__Signature Proto__Signature;
typedef struct Proto__ThresholdSignature Proto__ThresholdSignature;
typedef struct Proto__SignatureList Proto__SignatureList;
typedef struct Proto__SignaturePair Proto__SignaturePair;
typedef struct Proto__SignatureMap Proto__SignatureMap;
typedef struct Proto__FeeComponents Proto__FeeComponents;
typedef struct Proto__TransactionFeeSchedule Proto__TransactionFeeSchedule;
typedef struct Proto__FeeData Proto__FeeData;
typedef struct Proto__FeeSchedule Proto__FeeSchedule;
typedef struct Proto__CurrentAndNextFeeSchedule Proto__CurrentAndNextFeeSchedule;
typedef struct Proto__ServiceEndpoint Proto__ServiceEndpoint;
typedef struct Proto__NodeAddress Proto__NodeAddress;
typedef struct Proto__NodeAddressBook Proto__NodeAddressBook;
typedef struct Proto__SemanticVersion Proto__SemanticVersion;
typedef struct Proto__Setting Proto__Setting;
typedef struct Proto__ServicesConfigurationList Proto__ServicesConfigurationList;
typedef struct Proto__TokenRelationship Proto__TokenRelationship;
typedef struct Proto__TokenBalance Proto__TokenBalance;
typedef struct Proto__TokenBalances Proto__TokenBalances;


/* --- enums --- */

/*
 **
 * Possible Token Types (IWA Compatibility).
 * Apart from fungible and non-fungible, Tokens can have either a common or unique representation. This distinction might seem subtle, but it is important when considering
 * how tokens can be traced and if they can have isolated and unique properties.
 */
typedef enum _Proto__TokenType {
  /*
   **
   * Interchangeable value with one another, where any quantity of them has the same value as another equal quantity if they are in the same class.
   * Share a single set of properties, not distinct from one another. Simply represented as a balance or quantity to a given Hedera account.
   */
  PROTO__TOKEN_TYPE__FUNGIBLE_COMMON = 0,
  /*
   **
   * Unique, not interchangeable with other tokens of the same type as they typically have different values.
   * Individually traced and can carry unique properties (e.g. serial number).
   */
  PROTO__TOKEN_TYPE__NON_FUNGIBLE_UNIQUE = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__TOKEN_TYPE)
} Proto__TokenType;
/*
 **
 * Allows a set of resource prices to be scoped to a certain type of a HAPI operation. 
 * 
 * For example, the resource prices for a TokenMint operation are different between
 * minting fungible and non-fungible tokens. This enum allows us to "mark" a set of 
 * prices as applying to one or the other.
 * 
 * Similarly, the resource prices for a basic TokenCreate without a custom fee schedule 
 * yield a total price of $1. The resource prices for a TokenCreate with a custom fee 
 * schedule are different and yield a total base price of $2.
 */
typedef enum _Proto__SubType {
  /*
   * The resource prices have no special scope 
   */
  PROTO__SUB_TYPE__DEFAULT = 0,
  /*
   * The resource prices are scoped to an operation on a fungible common token
   */
  PROTO__SUB_TYPE__TOKEN_FUNGIBLE_COMMON = 1,
  /*
   * The resource prices are scoped to an operation on a non-fungible unique token
   */
  PROTO__SUB_TYPE__TOKEN_NON_FUNGIBLE_UNIQUE = 2,
  /*
   * The resource prices are scoped to an operation on a fungible common token with a custom fee schedule
   */
  PROTO__SUB_TYPE__TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES = 3,
  /*
   * The resource prices are scoped to an operation on a non-fungible unique token with a custom fee schedule
   */
  PROTO__SUB_TYPE__TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__SUB_TYPE)
} Proto__SubType;
/*
 **
 * Possible Token Supply Types (IWA Compatibility).
 * Indicates how many tokens can have during its lifetime.
 */
typedef enum _Proto__TokenSupplyType {
  /*
   * Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.
   */
  PROTO__TOKEN_SUPPLY_TYPE__INFINITE = 0,
  /*
   * Indicates that tokens of that type have an upper bound of maxSupply, provided on token creation.
   */
  PROTO__TOKEN_SUPPLY_TYPE__FINITE = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__TOKEN_SUPPLY_TYPE)
} Proto__TokenSupplyType;
/*
 * Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship 
 */
typedef enum _Proto__TokenFreezeStatus {
  PROTO__TOKEN_FREEZE_STATUS__FreezeNotApplicable = 0,
  PROTO__TOKEN_FREEZE_STATUS__Frozen = 1,
  PROTO__TOKEN_FREEZE_STATUS__Unfrozen = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__TOKEN_FREEZE_STATUS)
} Proto__TokenFreezeStatus;
/*
 * Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship 
 */
typedef enum _Proto__TokenKycStatus {
  PROTO__TOKEN_KYC_STATUS__KycNotApplicable = 0,
  PROTO__TOKEN_KYC_STATUS__Granted = 1,
  PROTO__TOKEN_KYC_STATUS__Revoked = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__TOKEN_KYC_STATUS)
} Proto__TokenKycStatus;
/*
 *The transactions and queries supported by Hedera Hashgraph.
 */
typedef enum _Proto__HederaFunctionality {
  /*
   * UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and not parsed (0 is ignored by parser)
   */
  PROTO__HEDERA_FUNCTIONALITY__NONE = 0,
  /*
   * crypto transfer
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoTransfer = 1,
  /*
   * crypto update account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoUpdate = 2,
  /*
   * crypto delete account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoDelete = 3,
  /*
   * Add a livehash to a crypto account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoAddLiveHash = 4,
  /*
   * Delete a livehash from a crypto account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoDeleteLiveHash = 5,
  /*
   * Smart Contract Call
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractCall = 6,
  /*
   * Smart Contract Create Contract
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractCreate = 7,
  /*
   * Smart Contract update contract
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractUpdate = 8,
  /*
   * File Operation create file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileCreate = 9,
  /*
   * File Operation append file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileAppend = 10,
  /*
   * File Operation update file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileUpdate = 11,
  /*
   * File Operation delete file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileDelete = 12,
  /*
   * crypto get account balance
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetAccountBalance = 13,
  /*
   * crypto get account record
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetAccountRecords = 14,
  /*
   * Crypto get info
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetInfo = 15,
  /*
   * Smart Contract Call
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractCallLocal = 16,
  /*
   * Smart Contract get info
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractGetInfo = 17,
  /*
   * Smart Contract, get the byte code
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractGetBytecode = 18,
  /*
   * Smart Contract, get by solidity ID
   */
  PROTO__HEDERA_FUNCTIONALITY__GetBySolidityID = 19,
  /*
   * Smart Contract, get by key
   */
  PROTO__HEDERA_FUNCTIONALITY__GetByKey = 20,
  /*
   * Get a live hash from a crypto account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetLiveHash = 21,
  /*
   * Crypto, get the stakers for the node
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetStakers = 22,
  /*
   * File Operations get file contents
   */
  PROTO__HEDERA_FUNCTIONALITY__FileGetContents = 23,
  /*
   * File Operations get the info of the file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileGetInfo = 24,
  /*
   * Crypto get the transaction records
   */
  PROTO__HEDERA_FUNCTIONALITY__TransactionGetRecord = 25,
  /*
   * Contract get the transaction records
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractGetRecords = 26,
  /*
   * crypto create account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoCreate = 27,
  /*
   * system delete file
   */
  PROTO__HEDERA_FUNCTIONALITY__SystemDelete = 28,
  /*
   * system undelete file
   */
  PROTO__HEDERA_FUNCTIONALITY__SystemUndelete = 29,
  /*
   * delete contract
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractDelete = 30,
  /*
   * freeze
   */
  PROTO__HEDERA_FUNCTIONALITY__Freeze = 31,
  /*
   * Create Tx Record
   */
  PROTO__HEDERA_FUNCTIONALITY__CreateTransactionRecord = 32,
  /*
   * Crypto Auto Renew
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoAccountAutoRenew = 33,
  /*
   * Contract Auto Renew
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractAutoRenew = 34,
  /*
   *Get Version
   */
  PROTO__HEDERA_FUNCTIONALITY__GetVersionInfo = 35,
  /*
   * Transaction Get Receipt
   */
  PROTO__HEDERA_FUNCTIONALITY__TransactionGetReceipt = 36,
  /*
   * Create Topic
   */
  PROTO__HEDERA_FUNCTIONALITY__ConsensusCreateTopic = 50,
  /*
   * Update Topic
   */
  PROTO__HEDERA_FUNCTIONALITY__ConsensusUpdateTopic = 51,
  /*
   * Delete Topic
   */
  PROTO__HEDERA_FUNCTIONALITY__ConsensusDeleteTopic = 52,
  /*
   * Get Topic information
   */
  PROTO__HEDERA_FUNCTIONALITY__ConsensusGetTopicInfo = 53,
  /*
   * Submit message to topic
   */
  PROTO__HEDERA_FUNCTIONALITY__ConsensusSubmitMessage = 54,
  PROTO__HEDERA_FUNCTIONALITY__UncheckedSubmit = 55,
  /*
   * Create Token
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenCreate = 56,
  /*
   * Get Token information
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenGetInfo = 58,
  /*
   * Freeze Account
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenFreezeAccount = 59,
  /*
   * Unfreeze Account
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenUnfreezeAccount = 60,
  /*
   * Grant KYC to Account
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenGrantKycToAccount = 61,
  /*
   * Revoke KYC from Account
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenRevokeKycFromAccount = 62,
  /*
   * Delete Token
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenDelete = 63,
  /*
   * Update Token
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenUpdate = 64,
  /*
   * Mint tokens to treasury
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenMint = 65,
  /*
   * Burn tokens from treasury
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenBurn = 66,
  /*
   * Wipe token amount from Account holder
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenAccountWipe = 67,
  /*
   * Associate tokens to an account
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenAssociateToAccount = 68,
  /*
   * Dissociate tokens from an account
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenDissociateFromAccount = 69,
  /*
   * Create Scheduled Transaction
   */
  PROTO__HEDERA_FUNCTIONALITY__ScheduleCreate = 70,
  /*
   * Delete Scheduled Transaction
   */
  PROTO__HEDERA_FUNCTIONALITY__ScheduleDelete = 71,
  /*
   * Sign Scheduled Transaction
   */
  PROTO__HEDERA_FUNCTIONALITY__ScheduleSign = 72,
  /*
   * Get Scheduled Transaction Information
   */
  PROTO__HEDERA_FUNCTIONALITY__ScheduleGetInfo = 73,
  /*
   * Get Token Account Nft Information
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenGetAccountNftInfos = 74,
  /*
   * Get Token Nft Information
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenGetNftInfo = 75,
  /*
   * Get Token Nft List Information
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenGetNftInfos = 76,
  /*
   * Update a token's custom fee schedule, if permissible
   */
  PROTO__HEDERA_FUNCTIONALITY__TokenFeeScheduleUpdate = 77
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__HEDERA_FUNCTIONALITY)
} Proto__HederaFunctionality;

/* --- messages --- */

/*
 * Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
 *Everything is partitioned into realms so that each Solidity smart contract can  access everything in just a single realm, locking all those entities while it's  running, but other smart contracts could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized somewhat, even though the  language itself assumes everything is serial. 
 */
struct  Proto__ShardID
{
  ProtobufCMessage base;
  /*
   *the shard number (nonnegative)
   */
  int64_t shardnum;
};
#define PROTO__SHARD_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__shard_id__descriptor) \
    , 0 }


/*
 * The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. 
 */
struct  Proto__RealmID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
};
#define PROTO__REALM_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__realm_id__descriptor) \
    , 0, 0 }


/*
 * The ID for an a cryptocurrency account  
 */
struct  Proto__AccountID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
  /*
   *A nonnegative account number unique within its realm
   */
  int64_t accountnum;
};
#define PROTO__ACCOUNT_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__account_id__descriptor) \
    , 0, 0, 0 }


/*
 * The ID for a file  
 */
struct  Proto__FileID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
  /*
   *A nonnegative File number unique within its realm
   */
  int64_t filenum;
};
#define PROTO__FILE_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__file_id__descriptor) \
    , 0, 0, 0 }


/*
 * The ID for a smart contract instance  
 */
struct  Proto__ContractID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
  /*
   *A nonnegative number unique within its realm
   */
  int64_t contractnum;
};
#define PROTO__CONTRACT_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__contract_id__descriptor) \
    , 0, 0, 0 }


/*
 *The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes.
 *Applicable to Scheduled Transactions:
 *- The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the ScheduleCreate transaction that created it. That is to say that they are equal
 *- The scheduled property is true for Scheduled Transactions
 *- transactionValidStart, accountID and scheduled properties should be omitted
 */
struct  Proto__TransactionID
{
  ProtobufCMessage base;
  /*
   * The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
   */
  Proto__Timestamp *transactionvalidstart;
  /*
   * The Account ID that paid for this transaction
   */
  Proto__AccountID *accountid;
  /*
   * Whether the Transaction is of type Scheduled or no
   */
  protobuf_c_boolean scheduled;
};
#define PROTO__TRANSACTION_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__transaction_id__descriptor) \
    , NULL, NULL, 0 }


/*
 * An account, and the amount that it sends or receives during a cryptocurrency or token transfer. 
 */
struct  Proto__AccountAmount
{
  ProtobufCMessage base;
  /*
   * The Account ID that sends/receives cryptocurrency or tokens
   */
  Proto__AccountID *accountid;
  /*
   * The amount of tinybars (for Crypto transfers) or in the lowest denomination (for Token transfers) that the account sends(negative) or receives(positive)
   */
  int64_t amount;
};
#define PROTO__ACCOUNT_AMOUNT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__account_amount__descriptor) \
    , NULL, 0 }


/*
 * A list of accounts and amounts to transfer out of each account (negative) or into it (positive). 
 */
struct  Proto__TransferList
{
  ProtobufCMessage base;
  /*
   * Multiple list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)
   */
  size_t n_accountamounts;
  Proto__AccountAmount **accountamounts;
};
#define PROTO__TRANSFER_LIST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__transfer_list__descriptor) \
    , 0,NULL }


/*
 * A sender account, a receiver account, and the serial number of an NFT of a Token with NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance (0.0.0) and when burning NFTs, the receiver will be the default AccountID instance. 
 */
struct  Proto__NftTransfer
{
  ProtobufCMessage base;
  /*
   * The accountID of the sender
   */
  Proto__AccountID *senderaccountid;
  /*
   * The accountID of the receiver
   */
  Proto__AccountID *receiveraccountid;
  /*
   * The serial number of the NFT
   */
  int64_t serialnumber;
};
#define PROTO__NFT_TRANSFER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__nft_transfer__descriptor) \
    , NULL, NULL, 0 }


/*
 * A list of token IDs and amounts representing the transferred out (negative) or into (positive) amounts, represented in the lowest denomination of the token 
 */
struct  Proto__TokenTransferList
{
  ProtobufCMessage base;
  /*
   * The ID of the token
   */
  Proto__TokenID *token;
  /*
   * Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which has an account and amount
   */
  size_t n_transfers;
  Proto__AccountAmount **transfers;
  /*
   * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of which has a sender and receiver account, including the serial number of the NFT
   */
  size_t n_nfttransfers;
  Proto__NftTransfer **nfttransfers;
};
#define PROTO__TOKEN_TRANSFER_LIST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_transfer_list__descriptor) \
    , NULL, 0,NULL, 0,NULL }


/*
 * A rational number, used to set the amount of a value transfer to collect as a custom fee 
 */
struct  Proto__Fraction
{
  ProtobufCMessage base;
  /*
   * The rational's numerator
   */
  int64_t numerator;
  /*
   * The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO
   */
  int64_t denominator;
};
#define PROTO__FRACTION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__fraction__descriptor) \
    , 0, 0 }


/*
 * Unique identifier for a topic (used by the consensus service) 
 */
struct  Proto__TopicID
{
  ProtobufCMessage base;
  /*
   * The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   * The realm number (nonnegative)
   */
  int64_t realmnum;
  /*
   * Unique topic identifier within a realm (nonnegative).
   */
  int64_t topicnum;
};
#define PROTO__TOPIC_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__topic_id__descriptor) \
    , 0, 0, 0 }


/*
 * Unique identifier for a token 
 */
struct  Proto__TokenID
{
  ProtobufCMessage base;
  /*
   * A nonnegative shard number
   */
  int64_t shardnum;
  /*
   * A nonnegative realm number
   */
  int64_t realmnum;
  /*
   * A nonnegative token number
   */
  int64_t tokennum;
};
#define PROTO__TOKEN_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_id__descriptor) \
    , 0, 0, 0 }


/*
 * Unique identifier for a Schedule 
 */
struct  Proto__ScheduleID
{
  ProtobufCMessage base;
  /*
   * A nonnegative shard number
   */
  int64_t shardnum;
  /*
   * A nonnegative realm number
   */
  int64_t realmnum;
  /*
   * A nonnegative schedule number
   */
  int64_t schedulenum;
};
#define PROTO__SCHEDULE_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__schedule_id__descriptor) \
    , 0, 0, 0 }


typedef enum {
  PROTO__KEY__KEY__NOT_SET = 0,
  PROTO__KEY__KEY_CONTRACT_ID = 1,
  PROTO__KEY__KEY_ED25519 = 2,
  PROTO__KEY__KEY_RSA_3072 = 3,
  PROTO__KEY__KEY_ECDSA_384 = 4,
  PROTO__KEY__KEY_THRESHOLD_KEY = 5,
  PROTO__KEY__KEY_KEY_LIST = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__KEY__KEY__CASE)
} Proto__Key__KeyCase;

/*
 * A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.
 * A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.
 * A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.
 *A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the documentation for a specific transaction type (e.g. FileDeleteTransactionBody).  Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key. A key list is always an M-of-M, unless specified otherwise in documentation. A key list can have nested key lists or threshold keys. Nested key lists are always M-of-M. A key list can have repeated Ed25519 public keys, but all repeated keys are only required to sign once.
 * A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive keys (e.g., ed25519) has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive keys (e.g., ed25519) has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
 * Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys. Only ed25519 primitive keys are currently supported.
 */
struct  Proto__Key
{
  ProtobufCMessage base;
  Proto__Key__KeyCase key_case;
  union {
    /*
     * smart contract instance that is authorized as if it had signed with a key
     */
    Proto__ContractID *contractid;
    /*
     * ed25519 public key bytes
     */
    ProtobufCBinaryData ed25519;
    /*
     * RSA-3072 public key bytes
     */
    ProtobufCBinaryData rsa_3072;
    /*
     * ECDSA with the p-384 curve public key bytes
     */
    ProtobufCBinaryData ecdsa_384;
    /*
     * a threshold N followed by a list of M keys, any N of which are required to form a valid signature
     */
    Proto__ThresholdKey *thresholdkey;
    /*
     * A list of Keys of the Key type.
     */
    Proto__KeyList *keylist;
  };
};
#define PROTO__KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__key__descriptor) \
    , PROTO__KEY__KEY__NOT_SET, {0} }


/*
 * A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. 
 */
struct  Proto__ThresholdKey
{
  ProtobufCMessage base;
  /*
   * A valid signature set must have at least this many signatures
   */
  uint32_t threshold;
  /*
   * List of all the keys that can sign
   */
  Proto__KeyList *keys;
};
#define PROTO__THRESHOLD_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__threshold_key__descriptor) \
    , 0, NULL }


/*
 * A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in documentation. A KeyList may contain repeated keys, but all repeated keys are only required to sign once. 
 */
struct  Proto__KeyList
{
  ProtobufCMessage base;
  /*
   * list of keys
   */
  size_t n_keys;
  Proto__Key **keys;
};
#define PROTO__KEY_LIST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__key_list__descriptor) \
    , 0,NULL }


typedef enum {
  PROTO__SIGNATURE__SIGNATURE__NOT_SET = 0,
  PROTO__SIGNATURE__SIGNATURE_CONTRACT = 1,
  PROTO__SIGNATURE__SIGNATURE_ED25519 = 2,
  PROTO__SIGNATURE__SIGNATURE_RSA_3072 = 3,
  PROTO__SIGNATURE__SIGNATURE_ECDSA_384 = 4,
  PROTO__SIGNATURE__SIGNATURE_THRESHOLD_SIGNATURE = 5,
  PROTO__SIGNATURE__SIGNATURE_SIGNATURE_LIST = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__SIGNATURE__SIGNATURE__CASE)
} Proto__Signature__SignatureCase;

/*
 * A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.
 * The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.
 * This message is deprecated and succeeded by SignaturePair and SignatureMap messages.
 */
struct  Proto__Signature
{
  ProtobufCMessage base;
  Proto__Signature__SignatureCase signature_case;
  union {
    /*
     * smart contract virtual signature (always length zero)
     */
    ProtobufCBinaryData contract;
    /*
     * ed25519 signature bytes
     */
    ProtobufCBinaryData ed25519;
    /*
     *RSA-3072 signature bytes
     */
    ProtobufCBinaryData rsa_3072;
    /*
     *ECDSA p-384 signature bytes
     */
    ProtobufCBinaryData ecdsa_384;
    /*
     * A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
     */
    Proto__ThresholdSignature *thresholdsignature;
    /*
     * A list of M signatures, each corresponding to a Key in a KeyList of the same length.
     */
    Proto__SignatureList *signaturelist;
  };
};
#define PROTO__SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature__descriptor) \
    , PROTO__SIGNATURE__SIGNATURE__NOT_SET, {0} }


/*
 *A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null.
 *This message is deprecated and succeeded by SignaturePair and SignatureMap messages.
 */
struct  Proto__ThresholdSignature
{
  ProtobufCMessage base;
  /*
   * for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null
   */
  Proto__SignatureList *sigs;
};
#define PROTO__THRESHOLD_SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__threshold_signature__descriptor) \
    , NULL }


/*
 *The signatures corresponding to a KeyList of the same length.
 *This message is deprecated and succeeded by SignaturePair and SignatureMap messages.
 */
struct  Proto__SignatureList
{
  ProtobufCMessage base;
  /*
   * each signature corresponds to a Key in the KeyList
   */
  size_t n_sigs;
  Proto__Signature **sigs;
};
#define PROTO__SIGNATURE_LIST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature_list__descriptor) \
    , 0,NULL }


typedef enum {
  PROTO__SIGNATURE_PAIR__SIGNATURE__NOT_SET = 0,
  PROTO__SIGNATURE_PAIR__SIGNATURE_CONTRACT = 2,
  PROTO__SIGNATURE_PAIR__SIGNATURE_ED25519 = 3,
  PROTO__SIGNATURE_PAIR__SIGNATURE_RSA_3072 = 4,
  PROTO__SIGNATURE_PAIR__SIGNATURE_ECDSA_384 = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__SIGNATURE_PAIR__SIGNATURE__CASE)
} Proto__SignaturePair__SignatureCase;

/*
 *The client may use any number of bytes from 0 to the whole length of the public key for pubKeyPrefix.
 *If 0 bytes is used, then it is assumed that only one public key is used to sign. Only ed25519
 *keys and hence signatures are currently supported.  
 */
struct  Proto__SignaturePair
{
  ProtobufCMessage base;
  /*
   * First few bytes of the public key
   */
  ProtobufCBinaryData pubkeyprefix;
  Proto__SignaturePair__SignatureCase signature_case;
  union {
    /*
     * smart contract virtual signature (always length zero)
     */
    ProtobufCBinaryData contract;
    /*
     * ed25519 signature
     */
    ProtobufCBinaryData ed25519;
    /*
     *RSA-3072 signature
     */
    ProtobufCBinaryData rsa_3072;
    /*
     *ECDSA p-384 signature
     */
    ProtobufCBinaryData ecdsa_384;
  };
};
#define PROTO__SIGNATURE_PAIR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature_pair__descriptor) \
    , {0,NULL}, PROTO__SIGNATURE_PAIR__SIGNATURE__NOT_SET, {0} }


/*
 *A set of signatures corresponding to every unique public key used to sign a given transaction. If one public key matches more than one prefixes on the signature map, the transaction containing the map will fail immediately with the response code KEY_PREFIX_MISMATCH.
 */
struct  Proto__SignatureMap
{
  ProtobufCMessage base;
  /*
   * Each signature pair corresponds to a unique Key required to sign the transaction.
   */
  size_t n_sigpair;
  Proto__SignaturePair **sigpair;
};
#define PROTO__SIGNATURE_MAP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature_map__descriptor) \
    , 0,NULL }


/*
 *A set of prices the nodes use in determining transaction and query fees, and constants involved in fee calculations.
 *Nodes multiply the amount of resources consumed by a transaction or query by the corresponding price to calculate the
 *appropriate fee. Units are one-thousandth of a tinyCent.
 */
struct  Proto__FeeComponents
{
  ProtobufCMessage base;
  /*
   * A minimum, the calculated fee must be greater than this value
   */
  int64_t min;
  /*
   * A maximum, the calculated fee must be less than this value
   */
  int64_t max;
  /*
   * A constant contribution to the fee
   */
  int64_t constant;
  /*
   * The price of bandwidth consumed by a transaction, measured in bytes
   */
  int64_t bpt;
  /*
   * The price per signature verification for a transaction
   */
  int64_t vpt;
  /*
   * The price of RAM consumed by a transaction, measured in byte-hours
   */
  int64_t rbh;
  /*
   * The price of storage consumed by a transaction, measured in byte-hours
   */
  int64_t sbh;
  /*
   * The price of computation for a smart contract transaction, measured in gas
   */
  int64_t gas;
  /*
   * The price per hbar transferred for a transfer
   */
  int64_t tv;
  /*
   * The price of bandwidth for data retrieved from memory for a response, measured in bytes
   */
  int64_t bpr;
  /*
   * The price of bandwidth for data retrieved from disk for a response, measured in bytes
   */
  int64_t sbpr;
};
#define PROTO__FEE_COMPONENTS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__fee_components__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


/*
 * The fees for a specific transaction or query based on the fee data. 
 */
struct  Proto__TransactionFeeSchedule
{
  ProtobufCMessage base;
  /*
   * A particular transaction or query
   */
  Proto__HederaFunctionality hederafunctionality;
  /*
   * Resource price coefficients
   */
  Proto__FeeData *feedata PROTOBUF_C__DEPRECATED;
  /*
   * Resource price coefficients. Supports subtype price definition.
   */
  size_t n_fees;
  Proto__FeeData **fees;
};
#define PROTO__TRANSACTION_FEE_SCHEDULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__transaction_fee_schedule__descriptor) \
    , PROTO__HEDERA_FUNCTIONALITY__NONE, NULL, 0,NULL }


/*
 *The total fee charged for a transaction. It is composed of three components â€“ a node fee that compensates the specific node that submitted the transaction, a network fee that compensates the network for assigning the transaction a consensus timestamp, and a service fee that compensates the network for the ongoing maintenance of the consequences of the transaction.
 */
struct  Proto__FeeData
{
  ProtobufCMessage base;
  /*
   * Fee paid to the submitting node
   */
  Proto__FeeComponents *nodedata;
  /*
   * Fee paid to the network for processing a transaction into consensus
   */
  Proto__FeeComponents *networkdata;
  /*
   * Fee paid to the network for providing the service associated with the transaction; for instance, storing a file
   */
  Proto__FeeComponents *servicedata;
  /*
   * SubType distinguishing between different types of FeeData, correlating to the same HederaFunctionality
   */
  Proto__SubType subtype;
};
#define PROTO__FEE_DATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__fee_data__descriptor) \
    , NULL, NULL, NULL, PROTO__SUB_TYPE__DEFAULT }


/*
 *A list of resource prices fee for different transactions and queries and the time period at which this fee schedule will expire. Nodes use the prices to determine the fees for all transactions based on how much of those resources each transaction uses.
 */
struct  Proto__FeeSchedule
{
  ProtobufCMessage base;
  /*
   * List of price coefficients for network resources
   */
  size_t n_transactionfeeschedule;
  Proto__TransactionFeeSchedule **transactionfeeschedule;
  /*
   * FeeSchedule expiry time
   */
  Proto__TimestampSeconds *expirytime;
};
#define PROTO__FEE_SCHEDULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__fee_schedule__descriptor) \
    , 0,NULL, NULL }


/*
 * This contains two Fee Schedules with expiry timestamp. 
 */
struct  Proto__CurrentAndNextFeeSchedule
{
  ProtobufCMessage base;
  /*
   * Contains current Fee Schedule
   */
  Proto__FeeSchedule *currentfeeschedule;
  /*
   * Contains next Fee Schedule
   */
  Proto__FeeSchedule *nextfeeschedule;
};
#define PROTO__CURRENT_AND_NEXT_FEE_SCHEDULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__current_and_next_fee_schedule__descriptor) \
    , NULL, NULL }


/*
 *Contains the IP address and the port representing a service endpoint of a Node in a network. Used to reach the Hedera API and submit transactions to the network.
 */
struct  Proto__ServiceEndpoint
{
  ProtobufCMessage base;
  /*
   * The 32-bit IPv4 address of the node encoded in left to right order (e.g. 127.0.0.1 has 127 as its first byte)
   */
  ProtobufCBinaryData ipaddressv4;
  /*
   * The port of the node
   */
  int32_t port;
};
#define PROTO__SERVICE_ENDPOINT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__service_endpoint__descriptor) \
    , {0,NULL}, 0 }


/*
 *The data about a node, including its service endpoints and the Hedera account to be paid for services
 *provided by the node (that is, queries answered and transactions submitted.)
 *If the <tt>serviceEndpoint</tt> list is not set, or empty, then the endpoint given by the (deprecated)
 *<tt>ipAddress</tt> and <tt>portno</tt> fields should be used.
 *All fields are populated in the 0.0.102 address book file while only fields that start with # are populated in the 0.0.101 address book file.
 */
struct  Proto__NodeAddress
{
  ProtobufCMessage base;
  /*
   * The IP address of the Node with separator & octets encoded in UTF-8. Usage is deprecated, ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
   */
  ProtobufCBinaryData ipaddress PROTOBUF_C__DEPRECATED;
  /*
   * The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
   */
  int32_t portno PROTOBUF_C__DEPRECATED;
  /*
   * Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID
   */
  ProtobufCBinaryData memo PROTOBUF_C__DEPRECATED;
  /*
   * The node's hex-encoded X509 RSA public key
   */
  char *rsa_pubkey;
  /*
   * # A non-sequential identifier for the node
   */
  int64_t nodeid;
  /*
   * # The account to be paid for queries and transactions sent to this node
   */
  Proto__AccountID *nodeaccountid;
  /*
   * # The hex-encoded SHA-384 hash of the X509 cert used to encrypt gRPC traffic to the node
   */
  ProtobufCBinaryData nodecerthash;
  /*
   * # A node's service IP addresses and ports
   */
  size_t n_serviceendpoint;
  Proto__ServiceEndpoint **serviceendpoint;
  /*
   * A description of the node, with UTF-8 encoding up to 100 bytes
   */
  char *description;
  /*
   * The amount of tinybars staked to the node
   */
  int64_t stake;
};
#define PROTO__NODE_ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__node_address__descriptor) \
    , {0,NULL}, 0, {0,NULL}, (char *)protobuf_c_empty_string, 0, NULL, {0,NULL}, 0,NULL, (char *)protobuf_c_empty_string, 0 }


/*
 *A list of nodes and their metadata that contains all details of the nodes for the network.
 *Used to parse the contents of system files <tt>0.0.101</tt> and <tt>0.0.102</tt>.
 */
struct  Proto__NodeAddressBook
{
  ProtobufCMessage base;
  /*
   * Metadata of all nodes in the network
   */
  size_t n_nodeaddress;
  Proto__NodeAddress **nodeaddress;
};
#define PROTO__NODE_ADDRESS_BOOK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__node_address_book__descriptor) \
    , 0,NULL }


/*
 * Hedera follows semantic versioning (https://semver.org/) for both the HAPI protobufs and the Services software.
 *This type allows the <tt>getVersionInfo</tt> query in the <tt>NetworkService</tt> to return the deployed versions
 *of both protobufs and software on the node answering the query. 
 */
struct  Proto__SemanticVersion
{
  ProtobufCMessage base;
  /*
   * Increases with incompatible API changes
   */
  int32_t major;
  /*
   * Increases with backwards-compatible new functionality
   */
  int32_t minor;
  /*
   * Increases with backwards-compatible bug fixes
   */
  int32_t patch;
  /*
   * A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3, this field would contain 'alpha.1'
   */
  char *pre;
  /*
   * Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field would contain '21AF26D3'
   */
  char *build;
};
#define PROTO__SEMANTIC_VERSION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__semantic_version__descriptor) \
    , 0, 0, 0, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string }


struct  Proto__Setting
{
  ProtobufCMessage base;
  /*
   * name of the property
   */
  char *name;
  /*
   * value of the property
   */
  char *value;
  /*
   * any data associated with property
   */
  ProtobufCBinaryData data;
};
#define PROTO__SETTING__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__setting__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, {0,NULL} }


struct  Proto__ServicesConfigurationList
{
  ProtobufCMessage base;
  /*
   * list of name value pairs of the application properties
   */
  size_t n_namevalue;
  Proto__Setting **namevalue;
};
#define PROTO__SERVICES_CONFIGURATION_LIST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__services_configuration_list__descriptor) \
    , 0,NULL }


/*
 * Token's information related to the given Account 
 */
struct  Proto__TokenRelationship
{
  ProtobufCMessage base;
  /*
   * The ID of the token
   */
  Proto__TokenID *tokenid;
  /*
   * The Symbol of the token
   */
  char *symbol;
  /*
   * For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
   */
  uint64_t balance;
  /*
   * The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not have KYC key, KycNotApplicable is returned
   */
  Proto__TokenKycStatus kycstatus;
  /*
   * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does not have Freeze key, FreezeNotApplicable is returned
   */
  Proto__TokenFreezeStatus freezestatus;
  /*
   * Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
   */
  uint32_t decimals;
};
#define PROTO__TOKEN_RELATIONSHIP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_relationship__descriptor) \
    , NULL, (char *)protobuf_c_empty_string, 0, PROTO__TOKEN_KYC_STATUS__KycNotApplicable, PROTO__TOKEN_FREEZE_STATUS__FreezeNotApplicable, 0 }


/*
 * A number of <i>transferable units</i> of a certain token.
 *The transferable unit of a token is its smallest denomination, as given by the token's <tt>decimals</tt> property---each minted token contains <tt>10<sup>decimals</sup></tt> transferable units. For example, we could think of the cent as the transferable unit of the US dollar (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar (<tt>decimals=8</tt>).
 *Transferable units are not directly comparable across different tokens. 
 */
struct  Proto__TokenBalance
{
  ProtobufCMessage base;
  /*
   * A unique token id
   */
  Proto__TokenID *tokenid;
  /*
   * Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON - balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
   */
  uint64_t balance;
  /*
   * Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
   */
  uint32_t decimals;
};
#define PROTO__TOKEN_BALANCE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_balance__descriptor) \
    , NULL, 0, 0 }


/*
 * A sequence of token balances 
 */
struct  Proto__TokenBalances
{
  ProtobufCMessage base;
  size_t n_tokenbalances;
  Proto__TokenBalance **tokenbalances;
};
#define PROTO__TOKEN_BALANCES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__token_balances__descriptor) \
    , 0,NULL }


/* Proto__ShardID methods */
void   proto__shard_id__init
                     (Proto__ShardID         *message);
size_t proto__shard_id__get_packed_size
                     (const Proto__ShardID   *message);
size_t proto__shard_id__pack
                     (const Proto__ShardID   *message,
                      uint8_t             *out);
size_t proto__shard_id__pack_to_buffer
                     (const Proto__ShardID   *message,
                      ProtobufCBuffer     *buffer);
Proto__ShardID *
       proto__shard_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__shard_id__free_unpacked
                     (Proto__ShardID *message,
                      ProtobufCAllocator *allocator);
/* Proto__RealmID methods */
void   proto__realm_id__init
                     (Proto__RealmID         *message);
size_t proto__realm_id__get_packed_size
                     (const Proto__RealmID   *message);
size_t proto__realm_id__pack
                     (const Proto__RealmID   *message,
                      uint8_t             *out);
size_t proto__realm_id__pack_to_buffer
                     (const Proto__RealmID   *message,
                      ProtobufCBuffer     *buffer);
Proto__RealmID *
       proto__realm_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__realm_id__free_unpacked
                     (Proto__RealmID *message,
                      ProtobufCAllocator *allocator);
/* Proto__AccountID methods */
void   proto__account_id__init
                     (Proto__AccountID         *message);
size_t proto__account_id__get_packed_size
                     (const Proto__AccountID   *message);
size_t proto__account_id__pack
                     (const Proto__AccountID   *message,
                      uint8_t             *out);
size_t proto__account_id__pack_to_buffer
                     (const Proto__AccountID   *message,
                      ProtobufCBuffer     *buffer);
Proto__AccountID *
       proto__account_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__account_id__free_unpacked
                     (Proto__AccountID *message,
                      ProtobufCAllocator *allocator);
/* Proto__FileID methods */
void   proto__file_id__init
                     (Proto__FileID         *message);
size_t proto__file_id__get_packed_size
                     (const Proto__FileID   *message);
size_t proto__file_id__pack
                     (const Proto__FileID   *message,
                      uint8_t             *out);
size_t proto__file_id__pack_to_buffer
                     (const Proto__FileID   *message,
                      ProtobufCBuffer     *buffer);
Proto__FileID *
       proto__file_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__file_id__free_unpacked
                     (Proto__FileID *message,
                      ProtobufCAllocator *allocator);
/* Proto__ContractID methods */
void   proto__contract_id__init
                     (Proto__ContractID         *message);
size_t proto__contract_id__get_packed_size
                     (const Proto__ContractID   *message);
size_t proto__contract_id__pack
                     (const Proto__ContractID   *message,
                      uint8_t             *out);
size_t proto__contract_id__pack_to_buffer
                     (const Proto__ContractID   *message,
                      ProtobufCBuffer     *buffer);
Proto__ContractID *
       proto__contract_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__contract_id__free_unpacked
                     (Proto__ContractID *message,
                      ProtobufCAllocator *allocator);
/* Proto__TransactionID methods */
void   proto__transaction_id__init
                     (Proto__TransactionID         *message);
size_t proto__transaction_id__get_packed_size
                     (const Proto__TransactionID   *message);
size_t proto__transaction_id__pack
                     (const Proto__TransactionID   *message,
                      uint8_t             *out);
size_t proto__transaction_id__pack_to_buffer
                     (const Proto__TransactionID   *message,
                      ProtobufCBuffer     *buffer);
Proto__TransactionID *
       proto__transaction_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__transaction_id__free_unpacked
                     (Proto__TransactionID *message,
                      ProtobufCAllocator *allocator);
/* Proto__AccountAmount methods */
void   proto__account_amount__init
                     (Proto__AccountAmount         *message);
size_t proto__account_amount__get_packed_size
                     (const Proto__AccountAmount   *message);
size_t proto__account_amount__pack
                     (const Proto__AccountAmount   *message,
                      uint8_t             *out);
size_t proto__account_amount__pack_to_buffer
                     (const Proto__AccountAmount   *message,
                      ProtobufCBuffer     *buffer);
Proto__AccountAmount *
       proto__account_amount__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__account_amount__free_unpacked
                     (Proto__AccountAmount *message,
                      ProtobufCAllocator *allocator);
/* Proto__TransferList methods */
void   proto__transfer_list__init
                     (Proto__TransferList         *message);
size_t proto__transfer_list__get_packed_size
                     (const Proto__TransferList   *message);
size_t proto__transfer_list__pack
                     (const Proto__TransferList   *message,
                      uint8_t             *out);
size_t proto__transfer_list__pack_to_buffer
                     (const Proto__TransferList   *message,
                      ProtobufCBuffer     *buffer);
Proto__TransferList *
       proto__transfer_list__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__transfer_list__free_unpacked
                     (Proto__TransferList *message,
                      ProtobufCAllocator *allocator);
/* Proto__NftTransfer methods */
void   proto__nft_transfer__init
                     (Proto__NftTransfer         *message);
size_t proto__nft_transfer__get_packed_size
                     (const Proto__NftTransfer   *message);
size_t proto__nft_transfer__pack
                     (const Proto__NftTransfer   *message,
                      uint8_t             *out);
size_t proto__nft_transfer__pack_to_buffer
                     (const Proto__NftTransfer   *message,
                      ProtobufCBuffer     *buffer);
Proto__NftTransfer *
       proto__nft_transfer__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__nft_transfer__free_unpacked
                     (Proto__NftTransfer *message,
                      ProtobufCAllocator *allocator);
/* Proto__TokenTransferList methods */
void   proto__token_transfer_list__init
                     (Proto__TokenTransferList         *message);
size_t proto__token_transfer_list__get_packed_size
                     (const Proto__TokenTransferList   *message);
size_t proto__token_transfer_list__pack
                     (const Proto__TokenTransferList   *message,
                      uint8_t             *out);
size_t proto__token_transfer_list__pack_to_buffer
                     (const Proto__TokenTransferList   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenTransferList *
       proto__token_transfer_list__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_transfer_list__free_unpacked
                     (Proto__TokenTransferList *message,
                      ProtobufCAllocator *allocator);
/* Proto__Fraction methods */
void   proto__fraction__init
                     (Proto__Fraction         *message);
size_t proto__fraction__get_packed_size
                     (const Proto__Fraction   *message);
size_t proto__fraction__pack
                     (const Proto__Fraction   *message,
                      uint8_t             *out);
size_t proto__fraction__pack_to_buffer
                     (const Proto__Fraction   *message,
                      ProtobufCBuffer     *buffer);
Proto__Fraction *
       proto__fraction__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__fraction__free_unpacked
                     (Proto__Fraction *message,
                      ProtobufCAllocator *allocator);
/* Proto__TopicID methods */
void   proto__topic_id__init
                     (Proto__TopicID         *message);
size_t proto__topic_id__get_packed_size
                     (const Proto__TopicID   *message);
size_t proto__topic_id__pack
                     (const Proto__TopicID   *message,
                      uint8_t             *out);
size_t proto__topic_id__pack_to_buffer
                     (const Proto__TopicID   *message,
                      ProtobufCBuffer     *buffer);
Proto__TopicID *
       proto__topic_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__topic_id__free_unpacked
                     (Proto__TopicID *message,
                      ProtobufCAllocator *allocator);
/* Proto__TokenID methods */
void   proto__token_id__init
                     (Proto__TokenID         *message);
size_t proto__token_id__get_packed_size
                     (const Proto__TokenID   *message);
size_t proto__token_id__pack
                     (const Proto__TokenID   *message,
                      uint8_t             *out);
size_t proto__token_id__pack_to_buffer
                     (const Proto__TokenID   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenID *
       proto__token_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_id__free_unpacked
                     (Proto__TokenID *message,
                      ProtobufCAllocator *allocator);
/* Proto__ScheduleID methods */
void   proto__schedule_id__init
                     (Proto__ScheduleID         *message);
size_t proto__schedule_id__get_packed_size
                     (const Proto__ScheduleID   *message);
size_t proto__schedule_id__pack
                     (const Proto__ScheduleID   *message,
                      uint8_t             *out);
size_t proto__schedule_id__pack_to_buffer
                     (const Proto__ScheduleID   *message,
                      ProtobufCBuffer     *buffer);
Proto__ScheduleID *
       proto__schedule_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__schedule_id__free_unpacked
                     (Proto__ScheduleID *message,
                      ProtobufCAllocator *allocator);
/* Proto__Key methods */
void   proto__key__init
                     (Proto__Key         *message);
size_t proto__key__get_packed_size
                     (const Proto__Key   *message);
size_t proto__key__pack
                     (const Proto__Key   *message,
                      uint8_t             *out);
size_t proto__key__pack_to_buffer
                     (const Proto__Key   *message,
                      ProtobufCBuffer     *buffer);
Proto__Key *
       proto__key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__key__free_unpacked
                     (Proto__Key *message,
                      ProtobufCAllocator *allocator);
/* Proto__ThresholdKey methods */
void   proto__threshold_key__init
                     (Proto__ThresholdKey         *message);
size_t proto__threshold_key__get_packed_size
                     (const Proto__ThresholdKey   *message);
size_t proto__threshold_key__pack
                     (const Proto__ThresholdKey   *message,
                      uint8_t             *out);
size_t proto__threshold_key__pack_to_buffer
                     (const Proto__ThresholdKey   *message,
                      ProtobufCBuffer     *buffer);
Proto__ThresholdKey *
       proto__threshold_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__threshold_key__free_unpacked
                     (Proto__ThresholdKey *message,
                      ProtobufCAllocator *allocator);
/* Proto__KeyList methods */
void   proto__key_list__init
                     (Proto__KeyList         *message);
size_t proto__key_list__get_packed_size
                     (const Proto__KeyList   *message);
size_t proto__key_list__pack
                     (const Proto__KeyList   *message,
                      uint8_t             *out);
size_t proto__key_list__pack_to_buffer
                     (const Proto__KeyList   *message,
                      ProtobufCBuffer     *buffer);
Proto__KeyList *
       proto__key_list__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__key_list__free_unpacked
                     (Proto__KeyList *message,
                      ProtobufCAllocator *allocator);
/* Proto__Signature methods */
void   proto__signature__init
                     (Proto__Signature         *message);
size_t proto__signature__get_packed_size
                     (const Proto__Signature   *message);
size_t proto__signature__pack
                     (const Proto__Signature   *message,
                      uint8_t             *out);
size_t proto__signature__pack_to_buffer
                     (const Proto__Signature   *message,
                      ProtobufCBuffer     *buffer);
Proto__Signature *
       proto__signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature__free_unpacked
                     (Proto__Signature *message,
                      ProtobufCAllocator *allocator);
/* Proto__ThresholdSignature methods */
void   proto__threshold_signature__init
                     (Proto__ThresholdSignature         *message);
size_t proto__threshold_signature__get_packed_size
                     (const Proto__ThresholdSignature   *message);
size_t proto__threshold_signature__pack
                     (const Proto__ThresholdSignature   *message,
                      uint8_t             *out);
size_t proto__threshold_signature__pack_to_buffer
                     (const Proto__ThresholdSignature   *message,
                      ProtobufCBuffer     *buffer);
Proto__ThresholdSignature *
       proto__threshold_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__threshold_signature__free_unpacked
                     (Proto__ThresholdSignature *message,
                      ProtobufCAllocator *allocator);
/* Proto__SignatureList methods */
void   proto__signature_list__init
                     (Proto__SignatureList         *message);
size_t proto__signature_list__get_packed_size
                     (const Proto__SignatureList   *message);
size_t proto__signature_list__pack
                     (const Proto__SignatureList   *message,
                      uint8_t             *out);
size_t proto__signature_list__pack_to_buffer
                     (const Proto__SignatureList   *message,
                      ProtobufCBuffer     *buffer);
Proto__SignatureList *
       proto__signature_list__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature_list__free_unpacked
                     (Proto__SignatureList *message,
                      ProtobufCAllocator *allocator);
/* Proto__SignaturePair methods */
void   proto__signature_pair__init
                     (Proto__SignaturePair         *message);
size_t proto__signature_pair__get_packed_size
                     (const Proto__SignaturePair   *message);
size_t proto__signature_pair__pack
                     (const Proto__SignaturePair   *message,
                      uint8_t             *out);
size_t proto__signature_pair__pack_to_buffer
                     (const Proto__SignaturePair   *message,
                      ProtobufCBuffer     *buffer);
Proto__SignaturePair *
       proto__signature_pair__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature_pair__free_unpacked
                     (Proto__SignaturePair *message,
                      ProtobufCAllocator *allocator);
/* Proto__SignatureMap methods */
void   proto__signature_map__init
                     (Proto__SignatureMap         *message);
size_t proto__signature_map__get_packed_size
                     (const Proto__SignatureMap   *message);
size_t proto__signature_map__pack
                     (const Proto__SignatureMap   *message,
                      uint8_t             *out);
size_t proto__signature_map__pack_to_buffer
                     (const Proto__SignatureMap   *message,
                      ProtobufCBuffer     *buffer);
Proto__SignatureMap *
       proto__signature_map__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature_map__free_unpacked
                     (Proto__SignatureMap *message,
                      ProtobufCAllocator *allocator);
/* Proto__FeeComponents methods */
void   proto__fee_components__init
                     (Proto__FeeComponents         *message);
size_t proto__fee_components__get_packed_size
                     (const Proto__FeeComponents   *message);
size_t proto__fee_components__pack
                     (const Proto__FeeComponents   *message,
                      uint8_t             *out);
size_t proto__fee_components__pack_to_buffer
                     (const Proto__FeeComponents   *message,
                      ProtobufCBuffer     *buffer);
Proto__FeeComponents *
       proto__fee_components__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__fee_components__free_unpacked
                     (Proto__FeeComponents *message,
                      ProtobufCAllocator *allocator);
/* Proto__TransactionFeeSchedule methods */
void   proto__transaction_fee_schedule__init
                     (Proto__TransactionFeeSchedule         *message);
size_t proto__transaction_fee_schedule__get_packed_size
                     (const Proto__TransactionFeeSchedule   *message);
size_t proto__transaction_fee_schedule__pack
                     (const Proto__TransactionFeeSchedule   *message,
                      uint8_t             *out);
size_t proto__transaction_fee_schedule__pack_to_buffer
                     (const Proto__TransactionFeeSchedule   *message,
                      ProtobufCBuffer     *buffer);
Proto__TransactionFeeSchedule *
       proto__transaction_fee_schedule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__transaction_fee_schedule__free_unpacked
                     (Proto__TransactionFeeSchedule *message,
                      ProtobufCAllocator *allocator);
/* Proto__FeeData methods */
void   proto__fee_data__init
                     (Proto__FeeData         *message);
size_t proto__fee_data__get_packed_size
                     (const Proto__FeeData   *message);
size_t proto__fee_data__pack
                     (const Proto__FeeData   *message,
                      uint8_t             *out);
size_t proto__fee_data__pack_to_buffer
                     (const Proto__FeeData   *message,
                      ProtobufCBuffer     *buffer);
Proto__FeeData *
       proto__fee_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__fee_data__free_unpacked
                     (Proto__FeeData *message,
                      ProtobufCAllocator *allocator);
/* Proto__FeeSchedule methods */
void   proto__fee_schedule__init
                     (Proto__FeeSchedule         *message);
size_t proto__fee_schedule__get_packed_size
                     (const Proto__FeeSchedule   *message);
size_t proto__fee_schedule__pack
                     (const Proto__FeeSchedule   *message,
                      uint8_t             *out);
size_t proto__fee_schedule__pack_to_buffer
                     (const Proto__FeeSchedule   *message,
                      ProtobufCBuffer     *buffer);
Proto__FeeSchedule *
       proto__fee_schedule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__fee_schedule__free_unpacked
                     (Proto__FeeSchedule *message,
                      ProtobufCAllocator *allocator);
/* Proto__CurrentAndNextFeeSchedule methods */
void   proto__current_and_next_fee_schedule__init
                     (Proto__CurrentAndNextFeeSchedule         *message);
size_t proto__current_and_next_fee_schedule__get_packed_size
                     (const Proto__CurrentAndNextFeeSchedule   *message);
size_t proto__current_and_next_fee_schedule__pack
                     (const Proto__CurrentAndNextFeeSchedule   *message,
                      uint8_t             *out);
size_t proto__current_and_next_fee_schedule__pack_to_buffer
                     (const Proto__CurrentAndNextFeeSchedule   *message,
                      ProtobufCBuffer     *buffer);
Proto__CurrentAndNextFeeSchedule *
       proto__current_and_next_fee_schedule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__current_and_next_fee_schedule__free_unpacked
                     (Proto__CurrentAndNextFeeSchedule *message,
                      ProtobufCAllocator *allocator);
/* Proto__ServiceEndpoint methods */
void   proto__service_endpoint__init
                     (Proto__ServiceEndpoint         *message);
size_t proto__service_endpoint__get_packed_size
                     (const Proto__ServiceEndpoint   *message);
size_t proto__service_endpoint__pack
                     (const Proto__ServiceEndpoint   *message,
                      uint8_t             *out);
size_t proto__service_endpoint__pack_to_buffer
                     (const Proto__ServiceEndpoint   *message,
                      ProtobufCBuffer     *buffer);
Proto__ServiceEndpoint *
       proto__service_endpoint__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__service_endpoint__free_unpacked
                     (Proto__ServiceEndpoint *message,
                      ProtobufCAllocator *allocator);
/* Proto__NodeAddress methods */
void   proto__node_address__init
                     (Proto__NodeAddress         *message);
size_t proto__node_address__get_packed_size
                     (const Proto__NodeAddress   *message);
size_t proto__node_address__pack
                     (const Proto__NodeAddress   *message,
                      uint8_t             *out);
size_t proto__node_address__pack_to_buffer
                     (const Proto__NodeAddress   *message,
                      ProtobufCBuffer     *buffer);
Proto__NodeAddress *
       proto__node_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__node_address__free_unpacked
                     (Proto__NodeAddress *message,
                      ProtobufCAllocator *allocator);
/* Proto__NodeAddressBook methods */
void   proto__node_address_book__init
                     (Proto__NodeAddressBook         *message);
size_t proto__node_address_book__get_packed_size
                     (const Proto__NodeAddressBook   *message);
size_t proto__node_address_book__pack
                     (const Proto__NodeAddressBook   *message,
                      uint8_t             *out);
size_t proto__node_address_book__pack_to_buffer
                     (const Proto__NodeAddressBook   *message,
                      ProtobufCBuffer     *buffer);
Proto__NodeAddressBook *
       proto__node_address_book__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__node_address_book__free_unpacked
                     (Proto__NodeAddressBook *message,
                      ProtobufCAllocator *allocator);
/* Proto__SemanticVersion methods */
void   proto__semantic_version__init
                     (Proto__SemanticVersion         *message);
size_t proto__semantic_version__get_packed_size
                     (const Proto__SemanticVersion   *message);
size_t proto__semantic_version__pack
                     (const Proto__SemanticVersion   *message,
                      uint8_t             *out);
size_t proto__semantic_version__pack_to_buffer
                     (const Proto__SemanticVersion   *message,
                      ProtobufCBuffer     *buffer);
Proto__SemanticVersion *
       proto__semantic_version__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__semantic_version__free_unpacked
                     (Proto__SemanticVersion *message,
                      ProtobufCAllocator *allocator);
/* Proto__Setting methods */
void   proto__setting__init
                     (Proto__Setting         *message);
size_t proto__setting__get_packed_size
                     (const Proto__Setting   *message);
size_t proto__setting__pack
                     (const Proto__Setting   *message,
                      uint8_t             *out);
size_t proto__setting__pack_to_buffer
                     (const Proto__Setting   *message,
                      ProtobufCBuffer     *buffer);
Proto__Setting *
       proto__setting__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__setting__free_unpacked
                     (Proto__Setting *message,
                      ProtobufCAllocator *allocator);
/* Proto__ServicesConfigurationList methods */
void   proto__services_configuration_list__init
                     (Proto__ServicesConfigurationList         *message);
size_t proto__services_configuration_list__get_packed_size
                     (const Proto__ServicesConfigurationList   *message);
size_t proto__services_configuration_list__pack
                     (const Proto__ServicesConfigurationList   *message,
                      uint8_t             *out);
size_t proto__services_configuration_list__pack_to_buffer
                     (const Proto__ServicesConfigurationList   *message,
                      ProtobufCBuffer     *buffer);
Proto__ServicesConfigurationList *
       proto__services_configuration_list__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__services_configuration_list__free_unpacked
                     (Proto__ServicesConfigurationList *message,
                      ProtobufCAllocator *allocator);
/* Proto__TokenRelationship methods */
void   proto__token_relationship__init
                     (Proto__TokenRelationship         *message);
size_t proto__token_relationship__get_packed_size
                     (const Proto__TokenRelationship   *message);
size_t proto__token_relationship__pack
                     (const Proto__TokenRelationship   *message,
                      uint8_t             *out);
size_t proto__token_relationship__pack_to_buffer
                     (const Proto__TokenRelationship   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenRelationship *
       proto__token_relationship__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_relationship__free_unpacked
                     (Proto__TokenRelationship *message,
                      ProtobufCAllocator *allocator);
/* Proto__TokenBalance methods */
void   proto__token_balance__init
                     (Proto__TokenBalance         *message);
size_t proto__token_balance__get_packed_size
                     (const Proto__TokenBalance   *message);
size_t proto__token_balance__pack
                     (const Proto__TokenBalance   *message,
                      uint8_t             *out);
size_t proto__token_balance__pack_to_buffer
                     (const Proto__TokenBalance   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenBalance *
       proto__token_balance__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_balance__free_unpacked
                     (Proto__TokenBalance *message,
                      ProtobufCAllocator *allocator);
/* Proto__TokenBalances methods */
void   proto__token_balances__init
                     (Proto__TokenBalances         *message);
size_t proto__token_balances__get_packed_size
                     (const Proto__TokenBalances   *message);
size_t proto__token_balances__pack
                     (const Proto__TokenBalances   *message,
                      uint8_t             *out);
size_t proto__token_balances__pack_to_buffer
                     (const Proto__TokenBalances   *message,
                      ProtobufCBuffer     *buffer);
Proto__TokenBalances *
       proto__token_balances__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__token_balances__free_unpacked
                     (Proto__TokenBalances *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Proto__ShardID_Closure)
                 (const Proto__ShardID *message,
                  void *closure_data);
typedef void (*Proto__RealmID_Closure)
                 (const Proto__RealmID *message,
                  void *closure_data);
typedef void (*Proto__AccountID_Closure)
                 (const Proto__AccountID *message,
                  void *closure_data);
typedef void (*Proto__FileID_Closure)
                 (const Proto__FileID *message,
                  void *closure_data);
typedef void (*Proto__ContractID_Closure)
                 (const Proto__ContractID *message,
                  void *closure_data);
typedef void (*Proto__TransactionID_Closure)
                 (const Proto__TransactionID *message,
                  void *closure_data);
typedef void (*Proto__AccountAmount_Closure)
                 (const Proto__AccountAmount *message,
                  void *closure_data);
typedef void (*Proto__TransferList_Closure)
                 (const Proto__TransferList *message,
                  void *closure_data);
typedef void (*Proto__NftTransfer_Closure)
                 (const Proto__NftTransfer *message,
                  void *closure_data);
typedef void (*Proto__TokenTransferList_Closure)
                 (const Proto__TokenTransferList *message,
                  void *closure_data);
typedef void (*Proto__Fraction_Closure)
                 (const Proto__Fraction *message,
                  void *closure_data);
typedef void (*Proto__TopicID_Closure)
                 (const Proto__TopicID *message,
                  void *closure_data);
typedef void (*Proto__TokenID_Closure)
                 (const Proto__TokenID *message,
                  void *closure_data);
typedef void (*Proto__ScheduleID_Closure)
                 (const Proto__ScheduleID *message,
                  void *closure_data);
typedef void (*Proto__Key_Closure)
                 (const Proto__Key *message,
                  void *closure_data);
typedef void (*Proto__ThresholdKey_Closure)
                 (const Proto__ThresholdKey *message,
                  void *closure_data);
typedef void (*Proto__KeyList_Closure)
                 (const Proto__KeyList *message,
                  void *closure_data);
typedef void (*Proto__Signature_Closure)
                 (const Proto__Signature *message,
                  void *closure_data);
typedef void (*Proto__ThresholdSignature_Closure)
                 (const Proto__ThresholdSignature *message,
                  void *closure_data);
typedef void (*Proto__SignatureList_Closure)
                 (const Proto__SignatureList *message,
                  void *closure_data);
typedef void (*Proto__SignaturePair_Closure)
                 (const Proto__SignaturePair *message,
                  void *closure_data);
typedef void (*Proto__SignatureMap_Closure)
                 (const Proto__SignatureMap *message,
                  void *closure_data);
typedef void (*Proto__FeeComponents_Closure)
                 (const Proto__FeeComponents *message,
                  void *closure_data);
typedef void (*Proto__TransactionFeeSchedule_Closure)
                 (const Proto__TransactionFeeSchedule *message,
                  void *closure_data);
typedef void (*Proto__FeeData_Closure)
                 (const Proto__FeeData *message,
                  void *closure_data);
typedef void (*Proto__FeeSchedule_Closure)
                 (const Proto__FeeSchedule *message,
                  void *closure_data);
typedef void (*Proto__CurrentAndNextFeeSchedule_Closure)
                 (const Proto__CurrentAndNextFeeSchedule *message,
                  void *closure_data);
typedef void (*Proto__ServiceEndpoint_Closure)
                 (const Proto__ServiceEndpoint *message,
                  void *closure_data);
typedef void (*Proto__NodeAddress_Closure)
                 (const Proto__NodeAddress *message,
                  void *closure_data);
typedef void (*Proto__NodeAddressBook_Closure)
                 (const Proto__NodeAddressBook *message,
                  void *closure_data);
typedef void (*Proto__SemanticVersion_Closure)
                 (const Proto__SemanticVersion *message,
                  void *closure_data);
typedef void (*Proto__Setting_Closure)
                 (const Proto__Setting *message,
                  void *closure_data);
typedef void (*Proto__ServicesConfigurationList_Closure)
                 (const Proto__ServicesConfigurationList *message,
                  void *closure_data);
typedef void (*Proto__TokenRelationship_Closure)
                 (const Proto__TokenRelationship *message,
                  void *closure_data);
typedef void (*Proto__TokenBalance_Closure)
                 (const Proto__TokenBalance *message,
                  void *closure_data);
typedef void (*Proto__TokenBalances_Closure)
                 (const Proto__TokenBalances *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    proto__token_type__descriptor;
extern const ProtobufCEnumDescriptor    proto__sub_type__descriptor;
extern const ProtobufCEnumDescriptor    proto__token_supply_type__descriptor;
extern const ProtobufCEnumDescriptor    proto__token_freeze_status__descriptor;
extern const ProtobufCEnumDescriptor    proto__token_kyc_status__descriptor;
extern const ProtobufCEnumDescriptor    proto__hedera_functionality__descriptor;
extern const ProtobufCMessageDescriptor proto__shard_id__descriptor;
extern const ProtobufCMessageDescriptor proto__realm_id__descriptor;
extern const ProtobufCMessageDescriptor proto__account_id__descriptor;
extern const ProtobufCMessageDescriptor proto__file_id__descriptor;
extern const ProtobufCMessageDescriptor proto__contract_id__descriptor;
extern const ProtobufCMessageDescriptor proto__transaction_id__descriptor;
extern const ProtobufCMessageDescriptor proto__account_amount__descriptor;
extern const ProtobufCMessageDescriptor proto__transfer_list__descriptor;
extern const ProtobufCMessageDescriptor proto__nft_transfer__descriptor;
extern const ProtobufCMessageDescriptor proto__token_transfer_list__descriptor;
extern const ProtobufCMessageDescriptor proto__fraction__descriptor;
extern const ProtobufCMessageDescriptor proto__topic_id__descriptor;
extern const ProtobufCMessageDescriptor proto__token_id__descriptor;
extern const ProtobufCMessageDescriptor proto__schedule_id__descriptor;
extern const ProtobufCMessageDescriptor proto__key__descriptor;
extern const ProtobufCMessageDescriptor proto__threshold_key__descriptor;
extern const ProtobufCMessageDescriptor proto__key_list__descriptor;
extern const ProtobufCMessageDescriptor proto__signature__descriptor;
extern const ProtobufCMessageDescriptor proto__threshold_signature__descriptor;
extern const ProtobufCMessageDescriptor proto__signature_list__descriptor;
extern const ProtobufCMessageDescriptor proto__signature_pair__descriptor;
extern const ProtobufCMessageDescriptor proto__signature_map__descriptor;
extern const ProtobufCMessageDescriptor proto__fee_components__descriptor;
extern const ProtobufCMessageDescriptor proto__transaction_fee_schedule__descriptor;
extern const ProtobufCMessageDescriptor proto__fee_data__descriptor;
extern const ProtobufCMessageDescriptor proto__fee_schedule__descriptor;
extern const ProtobufCMessageDescriptor proto__current_and_next_fee_schedule__descriptor;
extern const ProtobufCMessageDescriptor proto__service_endpoint__descriptor;
extern const ProtobufCMessageDescriptor proto__node_address__descriptor;
extern const ProtobufCMessageDescriptor proto__node_address_book__descriptor;
extern const ProtobufCMessageDescriptor proto__semantic_version__descriptor;
extern const ProtobufCMessageDescriptor proto__setting__descriptor;
extern const ProtobufCMessageDescriptor proto__services_configuration_list__descriptor;
extern const ProtobufCMessageDescriptor proto__token_relationship__descriptor;
extern const ProtobufCMessageDescriptor proto__token_balance__descriptor;
extern const ProtobufCMessageDescriptor proto__token_balances__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_BasicTypes_2eproto__INCLUDED */
